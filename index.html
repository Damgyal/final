<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mobile OMR Scanner</title>
<style>
  body { font-family: system-ui, -apple-system, Roboto, Arial; margin:0; padding:0; background:#f4f7fb; color:#111827; }
  header { background:#1f6feb; color:white; padding:1rem; text-align:center; }
  header h1 { margin:0; font-size:1.3rem; }
  .container { max-width: 600px; margin: 1rem auto; background:white; padding:1rem; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.05); }
  label { font-weight:600; display:block; margin-top:10px; }
  input, button { width:100%; padding:10px; margin-top:5px; border-radius:6px; border:1px solid #cbd5e1; font-size:1rem; }
  button { background:#1f6feb; color:white; border:none; cursor:pointer; }
  button:hover { background:#155ab6; }
  .row { display:flex; gap:6px; align-items:center; margin-bottom:6px; flex-wrap:wrap; }
  #cameraWrapper { position:relative; width:100%; border:2px dashed #1f6feb; border-radius:12px; overflow:hidden; margin-top:1rem; }
  video, canvas { width:100%; height:auto; display:block; object-fit:contain; }
  #a4Overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; border:2px dashed #1f6feb; }
  table { width:100%; border-collapse: collapse; margin-top:10px; }
  table, th, td { border:1px solid #cbd5e1; }
  th, td { padding:6px; text-align:center; }
  .score { font-weight:bold; color:#1f6feb; margin-top:10px; text-align:center; }
</style>
</head>
<body>
<header><h1>Mobile OMR Scanner</h1></header>
<div class="container">

<h2>Answer Key Setup</h2>
<label>Number of Questions:</label>
<input type="number" id="numQuestions" min="1" max="200" value="5">
<button id="generateBtn">Generate Answer Inputs</button>
<div id="answerInputs"></div>

<h2>Live Camera / Snap OMR</h2>
<div id="cameraWrapper">
  <video id="video" autoplay playsinline></video>
  <canvas id="omrCanvas"></canvas>
  <div id="a4Overlay"></div>
</div>

<button id="snapBtn">Snap & Detect Sheet</button>
<button id="analyzeBtn">Analyze OMR</button>
<div id="results"></div>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
let video=document.getElementById('video');
let canvas=document.getElementById('omrCanvas');
let ctx=canvas.getContext('2d');
let snapBtn=document.getElementById('snapBtn');
let analyzeBtn=document.getElementById('analyzeBtn');
let resultsDiv=document.getElementById('results');
let correctAnswers=[];
let warped=null;

// Generate answer inputs
document.getElementById('generateBtn').addEventListener('click', ()=>{
  const n=parseInt(document.getElementById('numQuestions').value);
  correctAnswers=[];
  const container=document.getElementById('answerInputs');
  container.innerHTML='';
  for(let i=1;i<=n;i++){
    const row=document.createElement('div'); row.className='row';
    row.innerHTML=`<label>Q${i}:</label><input type="text" maxlength="1" id="ans${i}" placeholder="A-D">`;
    container.appendChild(row);
  }
});

// Open mobile camera
navigator.mediaDevices.getUserMedia({video:{facingMode:"environment"}})
.then(stream=>{video.srcObject=stream;})
.catch(err=>{alert("Camera access required: "+err);});

// Snap & detect sheet
snapBtn.addEventListener('click', ()=>{
  canvas.width=video.videoWidth;
  canvas.height=video.videoHeight;
  ctx.drawImage(video,0,0,canvas.width,canvas.height);

  const src=cv.imread(canvas);
  const gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY);
  const blur=new cv.Mat(); cv.GaussianBlur(gray,blur,new cv.Size(5,5),0);
  const edges=new cv.Mat(); cv.Canny(blur,edges,50,180);

  const contours=new cv.MatVector(); const hierarchy=new cv.Mat();
  cv.findContours(edges,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);

  let maxArea=0; let sheet=null;
  for(let i=0;i<contours.size();i++){
    const cnt=contours.get(i);
    const peri=cv.arcLength(cnt,true);
    const approx=new cv.Mat(); cv.approxPolyDP(cnt,approx,0.02*peri,true);
    if(approx.rows===4){
      const area=cv.contourArea(approx);
      if(area>maxArea){ maxArea=area; sheet=approx; }
    }
    cnt.delete();
  }

  if(sheet){
    let pts=[];
    for(let i=0;i<4;i++){ pts.push({x:sheet.intPtr(i,0)[0],y:sheet.intPtr(i,0)[1]}); }
    pts.sort((a,b)=>a.y-b.y);
    let top=[pts[0],pts[1]].sort((a,b)=>a.x-b.x);
    let bottom=[pts[2],pts[3]].sort((a,b)=>a.x-b.x);

    let srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[top[0].x,top[0].y, top[1].x,top[1].y, bottom[1].x,bottom[1].y, bottom[0].x,bottom[0].y]);
    let dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[0,0, canvas.width,0, canvas.width,canvas.height, 0,canvas.height]);
    warped=new cv.Mat();
    let M=cv.getPerspectiveTransform(srcTri,dstTri);
    cv.warpPerspective(src,warped,M,new cv.Size(canvas.width,canvas.height));
    cv.imshow(canvas,warped);
    srcTri.delete(); dstTri.delete(); M.delete();
  } else { alert("OMR sheet not detected."); }

  src.delete(); gray.delete(); blur.delete(); edges.delete(); contours.delete(); hierarchy.delete();
});

// --- AI-style bubble detection ---
function clusterXPositions(xs, xTol){
  xs=xs.slice().sort((a,b)=>a-b);
  const clusters=[];
  for(const x of xs){
    if(clusters.length===0){clusters.push([x]); continue;}
    const last=clusters[clusters.length-1];
    if(Math.abs(x-last.reduce((s,v)=>s+v,0)/last.length)<=xTol) last.push(x);
    else clusters.push([x]);
  }
  return clusters.map(c=>c.reduce((s,v)=>s+v,0)/c.length);
}
function getColumnIndexForX(columnCenters,x){
  let best=0,bestDist=Infinity;
  for(let i=0;i<columnCenters.length;i++){
    const d=Math.abs(columnCenters[i]-x);
    if(d<bestDist){bestDist=d; best=i;}
  } return best;
}
function rectToSafe(r,mat){
  const x=Math.max(0,Math.min(r.x,mat.cols-1));
  const y=Math.max(0,Math.min(r.y,mat.rows-1));
  const w=Math.max(1,Math.min(r.width,mat.cols-x));
  const h=Math.max(1,Math.min(r.height,mat.rows-y));
  return new cv.Rect(x,y,w,h);
}
function computeFillMetrics(threshMat,grayMat,rect){
  const safeR=rectToSafe(rect,threshMat);
  const roiThresh=threshMat.roi(safeR);
  const nonZero=cv.countNonZero(roiThresh);
  const binFill=nonZero/(safeR.width*safeR.height);
  const roiGray=grayMat.roi(safeR);
  const meanVal=cv.mean(roiGray)[0];
  const invMean=Math.max(0,(255-meanVal)/255);
  roiThresh.delete(); roiGray.delete();
  return {combined:0.65*binFill+0.35*invMean};
}
function sortByY(a,b){return a.y-b.y;}
function detectOMRAnswers(mat,numQuestions){
  const imgW=mat.cols,imgH=mat.rows;
  const xClusterTol=Math.max(12,Math.round(imgW*0.02));
  const yGroupTol=Math.max(16,Math.round(imgH*0.012));
  const gray=new cv.Mat(); cv.cvtColor(mat,gray,cv.COLOR_RGBA2GRAY);
  const blur=new cv.Mat(); cv.GaussianBlur(gray,blur,new cv.Size(5,5),0);
  const thresh=new cv.Mat(); cv.adaptiveThreshold(blur,thresh,255,cv.ADAPTIVE_THRESH_GAUSSIAN_C,cv.THRESH_BINARY_INV,31,10);
  const contours=new cv.MatVector(),hierarchy=new cv.Mat();
  cv.findContours(thresh,contours,hierarchy,cv.RETR_EXTERNAL,cv.CHAIN_APPROX_SIMPLE);
  let candidates=[];
  for(let i=0;i<contours.size();i++){
    const cnt=contours.get(i);
    const r=cv.boundingRect(cnt);
    const aspect=r.width/r.height; const area=r.width*r.height;
    if(aspect>0.6 && aspect<1.6 && area>120 && area<18000) candidates.push({x:r.x+r.width/2,y:r.y+r.height/2,rect:r});
    cnt.delete();
  }
  candidates.sort(sortByY);
  const rows=[]; for(const c of candidates){
    let placed=false;
    for(const r of rows){if(Math.abs(r[0].y-c.y)<=yGroupTol){r.push(c); placed=true; break;}}
    if(!placed) rows.push([c]);
  }
  rows.forEach(r=>r.sort((a,b)=>a.x-b.x));
  const allXs=candidates.map(c=>c.x);
  const columnCenters=clusterXPositions(allXs,xClusterTol);
  let skipLeftColumn=false;
  if(columnCenters.length>=4+1) skipLeftColumn=true;
  const answers=[];
  let processedRows=0;
  for(let ri=0;ri<rows.length && processedRows<numQuestions;ri++){
    let rowCells=rows[ri].slice();
    if(skipLeftColumn && rowCells.length>0) rowCells=rowCells.slice(1);
    if(rowCells.length===0){answers.push("None"); processedRows++; continue;}
    const fills=[];
    for(let ci=0;ci<rowCells.length;ci++){fills.push({idx:ci,combined:computeFillMetrics(thresh,gray,rowCells[ci].rect).combined});}
    const sorted=fills.slice().sort((a,b)=>b.combined-a.combined);
    const top=sorted[0]; const second=sorted[1]||{combined:0};
    const absMin=Math.max(0.008,0.0005*(imgW*imgH)/(1000*1000));
    if(top.combined<absMin) answers.push("None");
    else if(top.combined>second.combined*1.4) answers.push(["A","B","C","D","E","F","G","H"][top.idx]||"?");
    else answers.push("Multiple");
    processedRows++;
  }
  gray.delete(); blur.delete(); thresh.delete(); contours.delete(); hierarchy.delete();
  return answers;
}

// Analyze button
analyzeBtn.addEventListener('click', ()=>{
  if(!warped){alert("Snap OMR sheet first"); return;}
  const n=parseInt(document.getElementById('numQuestions').value);
  correctAnswers=[];
  for(let i=1;i<=n;i++){
    const val=document.getElementById('ans'+i)?.value.trim().toUpperCase();
    if(!val || !val.match(/^[A-Z]$/)){alert("Enter valid answers A-Z for all questions"); return;}
    correctAnswers.push(val);
  }
  const detected=detectOMRAnswers(warped,n);
  let score=0; let details=[];
  for(let i=0;i<n;i++){
    const stu=detected[i]||"None"; const correct=correctAnswers[i]||"?";
    const status=(stu===correct)?"✅":"❌";
    if(stu===correct) score++;
    details.push(`<tr><td>${i+1}</td><td>${stu}</td><td>${correct}</td><td>${status}</td></tr>`);
  }
  resultsDiv.innerHTML=`<h3>Results</h3>
    <table><tr><th>Q#</th><th>Student</th><th>Correct</th><th>Status</th></tr>
    ${details.join("")}</table>
    <p class="score">Score: ${score}/${n}</p>`;
});
</script>
</div>
</body>
</html>
